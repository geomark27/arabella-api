package dtos

import (
	"arabella-api/internal/app/models"
	"time"

	"github.com/shopspring/decimal"
)

// JournalEntryResponse represents a read-only journal entry response
// Journal entries are NOT directly created by users - they are generated by the Accounting Engine
type JournalEntryResponse struct {
	ID            uint            `json:"id"`
	UserID        uint            `json:"user_id"`
	TransactionID uint            `json:"transaction_id"`
	AccountID     uint            `json:"account_id"`
	DebitOrCredit string          `json:"debit_or_credit"` // "DEBIT" or "CREDIT"
	Amount        decimal.Decimal `json:"amount"`
	EntryDate     time.Time       `json:"entry_date"`
	Description   string          `json:"description"`
	CreatedAt     time.Time       `json:"created_at"`

	// Relationships
	Account *AccountSummary `json:"account,omitempty"`
}

// JournalEntryListResponse represents a paginated list of journal entries (for audit trail)
type JournalEntryListResponse struct {
	Entries    []JournalEntryResponse `json:"entries"`
	Total      int64                  `json:"total"`
	Page       int                    `json:"page"`
	PageSize   int                    `json:"page_size"`
	TotalPages int                    `json:"total_pages"`
}

// BalanceVerificationResponse shows the balance verification for a transaction or period
type BalanceVerificationResponse struct {
	TransactionID *uint           `json:"transaction_id,omitempty"`
	TotalDebits   decimal.Decimal `json:"total_debits"`
	TotalCredits  decimal.Decimal `json:"total_credits"`
	Difference    decimal.Decimal `json:"difference"` // Should be 0 for balanced transactions
	IsBalanced    bool            `json:"is_balanced"`
	Message       string          `json:"message"`
}

// AccountBalanceResponse represents the current balance of an account from journal entries
type AccountBalanceResponse struct {
	AccountID    uint            `json:"account_id"`
	AccountName  string          `json:"account_name"`
	AccountType  string          `json:"account_type"`
	TotalDebits  decimal.Decimal `json:"total_debits"`
	TotalCredits decimal.Decimal `json:"total_credits"`
	Balance      decimal.Decimal `json:"balance"` // Debits - Credits for assets, Credits - Debits for liabilities
	CurrencyCode string          `json:"currency_code"`
}

// BalanceSheetResponse represents a full balance sheet from journal entries
type BalanceSheetResponse struct {
	AsOf         time.Time                `json:"as_of"`
	Accounts     []AccountBalanceResponse `json:"accounts"`
	TotalDebits  decimal.Decimal          `json:"total_debits"`
	TotalCredits decimal.Decimal          `json:"total_credits"`
	IsBalanced   bool                     `json:"is_balanced"`
}

// JournalEntryFilters represents query parameters for filtering journal entries
type JournalEntryFilters struct {
	TransactionID *uint      `json:"transaction_id" validate:"omitempty,gt=0"`
	AccountID     *uint      `json:"account_id" validate:"omitempty,gt=0"`
	DebitOrCredit *string    `json:"debit_or_credit" validate:"omitempty,oneof=DEBIT CREDIT"`
	StartDate     *time.Time `json:"start_date" validate:"omitempty"`
	EndDate       *time.Time `json:"end_date" validate:"omitempty"`
	Page          int        `json:"page" validate:"omitempty,gte=1"`
	PageSize      int        `json:"page_size" validate:"omitempty,gte=1,lte=100"`
}

// FromModelToJournalEntryResponse converts models.JournalEntry to JournalEntryResponse
func FromModelToJournalEntryResponse(je *models.JournalEntry) JournalEntryResponse {
	resp := JournalEntryResponse{
		ID:            je.ID,
		UserID:        je.UserID,
		TransactionID: je.TransactionID,
		AccountID:     je.AccountID,
		DebitOrCredit: je.DebitOrCredit,
		Amount:        je.Amount,
		EntryDate:     je.EntryDate,
		Description:   je.Description,
		CreatedAt:     je.CreatedAt,
	}

	// Include account summary if loaded
	if je.Account.ID != 0 {
		accountSummary := AccountSummary{
			ID:       je.Account.ID,
			Name:     je.Account.Name,
			Type:     je.Account.AccountType,
			Balance:  je.Account.Balance,
			Currency: nil,
		}

		if je.Account.Currency != nil {
			currencySummary := CurrencySummary{
				ID:     je.Account.Currency.ID,
				Code:   je.Account.Currency.Code,
				Symbol: je.Account.Currency.Symbol,
			}
			accountSummary.Currency = &currencySummary
		}

		resp.Account = &accountSummary
	}

	return resp
}
